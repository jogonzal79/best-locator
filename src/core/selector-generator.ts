import { AIEngine } from './ai-engine.js';
import { BestLocatorConfig, SelectorResult, ElementInfo, PageContext } from '../types/index.js';
import { logger } from '../app/logger.js';

export class SelectorGenerator {
  private aiEngine?: AIEngine;
  private config: BestLocatorConfig;

  constructor(config: BestLocatorConfig) {
    this.config = config;
    if (config?.ai?.enabled) {
      this.aiEngine = new AIEngine(config);
    }
  }

  public async generateSelectorWithAI(elementInfo: ElementInfo, context: PageContext): Promise<SelectorResult> {
    // ... (la lógica de IA no cambia)
    const priorityResult = this.getPrioritySelector(elementInfo);
    if (priorityResult) {
      return priorityResult;
    }
    if (this.aiEngine && await this.aiEngine.isAvailable()) {
      try {
        const aiResult = await this.aiEngine.generateSelector(elementInfo, context);
        return { ...aiResult, reasoning: `Generated by ${this.config.ai.provider} AI.` };
      } catch (error) {
         logger.warning('⚠️ AI generation failed, falling back to traditional method.');
      }
    }
    return this.generateSelector(elementInfo);
  }

  // --- MÉTODO MANUAL CON LÓGICA DE PRIORIDADES MEJORADA ---
  public generateSelector(elementInfo: ElementInfo): SelectorResult {
    const { attributes, tagName, textContent, id, className } = elementInfo;

    // 1. Atributos de Test (leídos desde la config)
    for (const attr of this.config.projectAttributes) {
      if (attributes[attr]) {
        return this.result(`[${attr}="${attributes[attr]}"]`, 100, 'test-id', `Uses the project-specific test attribute '${attr}'.`);
      }
    }

    // 2. Atributos de accesibilidad y rol
    if (attributes['aria-label']) {
      return this.result(`${tagName}[aria-label="${attributes['aria-label']}"]`, 90, 'aria-label', 'Uses a highly specific accessibility attribute.');
    }
    if (attributes['role']) {
      return this.result(`${tagName}[role="${attributes['role']}"]`, 85, 'role', 'Uses the ARIA accessibility role.');
    }

    // 3. Atributos de formulario y funcionales
    if (attributes['name']) {
      return this.result(`${tagName}[name="${attributes['name']}"]`, 80, 'name', 'Uses the form element name attribute.');
    }
    if (id && !/^\d+$/.test(id)) {
      return this.result(`#${id}`, 75, 'id', 'Uses a unique ID.');
    }

    // 4. Selector de texto especial (manejado por el Formatter)
    const cleanText = textContent?.trim();
    if (cleanText && cleanText.length > 0 && cleanText.length < 50) {
      return this.result(`text="${cleanText}"`, 70, 'text', 'Uses the unique visible text content.');
    }

    // 5. Atributos de input
    if (attributes['placeholder']) {
      return this.result(`${tagName}[placeholder="${attributes['placeholder']}"]`, 65, 'placeholder', 'Uses the placeholder text.');
    }

    // 6. Clases CSS (lógica mejorada para buscar la clase más única)
    if (className) {
        const bestClass = className.split(' ')
            .filter(c => c && c.length > 3 && !/hover|active|disabled|focus|selected|--|__|jet/i.test(c))
            .sort((a, b) => b.length - a.length)[0]; // Prioriza la clase más larga y específica
        
        if (bestClass) {
            return this.result(`${tagName}.${bestClass}`, 50, 'class', 'Uses a combination of tag name and a likely stable CSS class.');
        }
    }
    
    // 7. Último recurso
    return this.result(tagName, 10, 'tag-only', 'Lowest priority: fallback to tag name.');
  }

  // Función de ayuda para crear resultados consistentes
  private result(selector: string, confidence: number, type: string, reasoning: string): SelectorResult {
    return { selector, confidence, type, reasoning };
  }

  private getPrioritySelector(elementInfo: ElementInfo): SelectorResult | null {
    for (const attr of this.config.projectAttributes) {
      if (elementInfo.attributes[attr]) {
        return this.result(`[${attr}="${elementInfo.attributes[attr]}"]`, 100, 'data-test-attribute', `Selected attribute '${attr}' - highest reliability.`);
      }
    }
    return null;
  }
}